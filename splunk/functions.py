#!/usr/bin/env python3
import os
import gzip
import csv
import re
import pprint
import requests # type: ignore
import ipaddress
from datetime import datetime
import configparser
from pathlib import Path

#----------------------
# Load config from file
#----------------------
def load_config(path: str) -> dict:
    """
    Load .ini config file and return a nested dict.
    Example:
        cfg['telegram']['bot_token']
    """
    config_path = Path(path)
    if not config_path.exists():
        raise FileNotFoundError(f"Config file not found: {path}")

    parser = configparser.ConfigParser()
    parser.optionxform = str  # gi·ªØ nguy√™n ch·ªØ hoa/th∆∞·ªùng
    parser.read(config_path, encoding="utf-8")

    cfg = {section: dict(parser.items(section)) for section in parser.sections()}
    return cfg


# -------------------------------
# IP / Range Whitelist functions
# -------------------------------

def load_whitelist(path="/opt/splunk/bin/scripts/whitelist.txt"):
    """
    ƒê·ªçc danh s√°ch whitelist IP/range t·ª´ file (m·ªói d√≤ng 1 IP ho·∫∑c CIDR).
    """
    whitelist = []
    if os.path.exists(path):
        with open(path) as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#"):
                    whitelist.append(line)
    return whitelist

def is_ip_whitelisted(ip, whitelist):
    """
    Ki·ªÉm tra IP c√≥ n·∫±m trong whitelist kh√¥ng.
    H·ªó tr·ª£ c·∫£ IP ƒë∆°n l·∫ª v√† CIDR range.
    """
    try:
        ip_obj = ipaddress.ip_address(ip)
        for net in whitelist:
            try:
                if ip_obj in ipaddress.ip_network(net, strict=False):
                    return True
            except ValueError:
                if ip == net:
                    return True
    except ValueError:
        pass
    return False

# -------------------------------
# Parse result file
# -------------------------------
def parse_result_file(result_file, whitelist=None,threshold=10000):
    """
    ƒê·ªçc file Splunk CSV.GZ, l·ªçc IP theo threshold v√† whitelist.
    """
    if whitelist is None:
        whitelist = []

    results = []
    THRESHOLD=threshold
    try:
        with gzip.open(result_file, 'rt', encoding='utf-8') as f:
            reader = csv.reader(f)
            next(reader, None)  # b·ªè header
            for row in reader:
                if len(row) < 3:
                    continue
                ip = row[0].replace('"', '').strip()
                domain = row[1].replace('"', '').strip()
                try:
                    hits = int(row[2].replace('"', '').strip())
                except ValueError:
                    continue

                if hits > THRESHOLD and not is_ip_whitelisted(ip, whitelist):
                    results.append((ip, domain, hits))
    except FileNotFoundError:
        return []

    return results

# -------------------------------
# Message Builder
# -------------------------------

def build_message(project, top_ips):
    """
    T·∫°o n·ªôi dung tin nh·∫Øn Telegram c·∫£nh b√°o.
    """
    if not top_ips:
        top_ips_str = "(no result or all IPs whitelisted)"
    else:
        top_ips_str = "\n".join(
            f"{p}:\n  {ip:<18} : {hits} hits"
            for ip, p, hits in top_ips
        )

    return (
        f"*Splunk Alert:* *{project}*\n"
        f"*Time:* {datetime.now():%Y-%m-%d %H:%M:%S}\n"
        f"*Top IPs:*\n"
        f"```\n{top_ips_str}\n```"
    )

# -------------------------------
# Telegram Sender
# -------------------------------

def send_telegram_message(bot_token, chat_id, message):
    """
    G·ª≠i tin nh·∫Øn t·ªõi Telegram qua Bot API.
    """
    url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
    payload = {
        "chat_id": chat_id,
        "parse_mode": "Markdown",
        "text": message
    }

    try:
        response = requests.post(url, data=payload, timeout=10)
        response.raise_for_status()
    except Exception as e:
        print(f"[Telegram Error] {e}")


def format_args(args):
    """Tr·∫£ v·ªÅ chu·ªói li·ªát k√™ to√†n b·ªô tham s·ªë."""
    return "\n".join([f"Param {i} = {arg}" for i, arg in enumerate(args, start=1)])

#------------------------------
# CF define functions
# ----------------------------
def is_ip_or_cidr(value):
    ip4 = r'^(\d{1,3}\.){3}\d{1,3}(/\d{1,2})?$'
    ipv6 = r'^([0-9a-fA-F:]+)(/\d{1,3})?$'
    return bool(re.match(ip4, value)) or bool(re.match(ipv6, value))


def is_domain(value):
    domain_pattern = r'^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z]{2,})+$'
    return bool(re.match(domain_pattern, value))


def get_zone_id_from_domain(cf_token, domain, account_id=None, timeout=10):
    """
    L·∫•y zone_id c·ªßa domain qua Cloudflare API.
    """
    headers = {
        "Authorization": f"Bearer {cf_token}",
        "Content-Type": "application/json",
    }
    parts = domain.strip().lower().split(".")
    if len(parts) > 2:
        root_domain = ".".join(parts[-2:])  # l·∫•y 2 ph·∫ßn cu·ªëi
        print(f"‚ÑπÔ∏è {domain} l√† subdomain, d√πng zone ID c·ªßa {root_domain}")
    else:
        root_domain = domain
    params = {"name": root_domain}
    if account_id:
        params["account.id"] = account_id

    url = "https://api.cloudflare.com/client/v4/zones"

    try:
        resp = requests.get(url, headers=headers, params=params, timeout=timeout)
        data = resp.json()
    except Exception as e:
        print(f"[CF] L·ªói khi g·ªçi API l·∫•y zone id cho {domain}: {e}")
        return None

    if resp.status_code != 200 or not data.get("success"):
        print(f"[CF] Kh√¥ng l·∫•y ƒë∆∞·ª£c zone id cho {domain}: {data}")
        return None

    results = data.get("result", [])
    if not results:
        print(f"[CF] Kh√¥ng t√¨m th·∫•y zone cho domain {domain}")
        return None

    return results[0].get("id")


def block_ip_on_domain(cf_token, domain, ip, bot_token,chat_id, description="Auto"):
    """
    Ch·∫∑n 1 IP ch·ªâ khi truy c·∫≠p domain c·ª• th·ªÉ tr√™n Cloudflare Firewall Rule.
    """
    msg=""
    if not is_domain(domain):
        send_telegram_message(bot_token, chat_id, "Domain kh√¥ng h·ª£p l·ªá: " + domain)
        print(f"‚ùå Domain kh√¥ng h·ª£p l·ªá: {domain}")
        return False
    if not is_ip_or_cidr(ip):
        send_telegram_message(bot_token, chat_id, "IP kh√¥ng h·ª£p l·ªá: " + ip)
        print(f"‚ùå IP kh√¥ng h·ª£p l·ªá: {ip}")
        return False

    zone_id = get_zone_id_from_domain(cf_token, domain)
    if not zone_id:
        send_telegram_message(bot_token, chat_id, "Kh√¥ng l·∫•y ƒë∆∞·ª£c Zone ID cho  " + domain)
        print(f"‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c Zone ID cho {domain}")
        return False

    headers = {
        "Authorization": f"Bearer {cf_token}",
        "Content-Type": "application/json"
    }
    description=description + "_" + domain + "_" + ip
    # Rule expression: ch·∫∑n IP ch·ªâ tr√™n domain n√†y
    expression = f'(http.host eq "{domain}") and (ip.src eq {ip})'
    ### Check trung
    api_url = f"https://api.cloudflare.com/client/v4/zones/{zone_id}/firewall/rules"

    # üîç Ki·ªÉm tra xem rule n√†y ƒë√£ t·ªìn t·∫°i ch∆∞a
    try:
        existing = requests.get(api_url, headers=headers, timeout=15).json()
        if existing.get("success"):
            for rule in existing.get("result", []):
                filt = rule.get("filter", {})
                if filt.get("expression") == expression:
                    send_telegram_message(bot_token, chat_id,"Rule ch·∫∑n "+ ip + " tr√™n domain " + domain + "ƒë√£ t·ªìn t·∫°i" )
                    print(f"‚ö†Ô∏è Rule ch·∫∑n {ip} tr√™n domain {domain} ƒë√£ t·ªìn t·∫°i (rule_id={rule['id']})")
                    return True
    except Exception as e:
        send_telegram_message(bot_token, chat_id, "Kh√¥ng th·ªÉ ki·ªÉm tra rule t·ªìn t·∫°i: " + e)
        print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ ki·ªÉm tra rule t·ªìn t·∫°i: {e}")
    
   # api_url = f"https://api.cloudflare.com/client/v4/zones/{zone_id}/firewall/rules"
    payload = [{
        "action": "block",
        "description": description,
        "filter": {
            "expression": expression,
            "paused": False
        }
    }]

    try:
        resp = requests.post(api_url, headers=headers, json=payload, timeout=15)
        data = resp.json()
        if resp.status_code in (200, 201) and data.get("success"):
            send_telegram_message(bot_token, chat_id, "ƒê√£ block IP " + ip +  " tr√™n domain " +  domain + " zone " + zone_id)
            print(f"‚úÖ ƒê√£ block IP {ip} tr√™n domain {domain} (zone {zone_id})")
            return True
        else:
            send_telegram_message(bot_token, chat_id, "L·ªói block IP " + ip +  " tr√™n "  + domain + ": " + data)
            print(f"‚ùå L·ªói block IP {ip} tr√™n {domain}: {data}")
            return False
    except Exception as e:
        send_telegram_message(bot_token, chat_id, "Exception khi block IP" +  ip + " tr√™n " + domain + ":" + e)
        print(f"‚ö†Ô∏è Exception khi block IP {ip} tr√™n {domain}: {e}")
        return False


##### Update Rule 
def block_ip_on_domain_new(cf_token, domain, ip, bot_token, chat_id, description="Auto"):
    """
    ‚úÖ C·∫≠p nh·∫≠t IP v√†o rule c√≥ t√™n 'AutoBlock-CustomRule' (duy nh·∫•t tr√™n zone)
    ‚úÖ Kh√¥ng t·∫°o th√™m unused filter
    ‚úÖ N·∫øu ch∆∞a c√≥ rule n√†y ‚Üí t·ª± t·∫°o m·ªõi
    """
    if not is_domain(domain):
        msg = f"‚ùå Domain kh√¥ng h·ª£p l·ªá: {domain}"
        send_telegram_message(bot_token, chat_id, msg)
        print(msg)
        return False
    if not is_ip_or_cidr(ip):
        msg = f"‚ùå IP kh√¥ng h·ª£p l·ªá: {ip}"
        send_telegram_message(bot_token, chat_id, msg)
        print(msg)
        return False

    zone_id = get_zone_id_from_domain(cf_token, domain)
    if not zone_id:
        msg = f"‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c Zone ID cho {domain}"
        send_telegram_message(bot_token, chat_id, msg)
        print(msg)
        return False

    headers = {
        "Authorization": f"Bearer {cf_token}",
        "Content-Type": "application/json"
    }

    api_rules = f"https://api.cloudflare.com/client/v4/zones/{zone_id}/firewall/rules"
    api_filters = f"https://api.cloudflare.com/client/v4/zones/{zone_id}/filters"

    try:
        # üîç L·∫•y danh s√°ch rule hi·ªán c√≥
        resp = requests.get(api_rules, headers=headers, timeout=15)
        rules = resp.json().get("result", []) if resp.ok else []

        # üîç T√¨m rule c√≥ description b·∫Øt ƒë·∫ßu b·∫±ng AutoBlock-CustomRule
        target_rule = None
        for r in rules:
            desc = r.get("description", "")
            if desc == "AutoBlock-CustomRule":
                target_rule = r
                break

        new_expr = f'(http.host eq "{domain}"  and ip.src eq {ip})'

        if target_rule:
            rule_id = target_rule["id"]
            filt = target_rule.get("filter", {})
            old_expr = filt.get("expression", "")
            old_filter_id = filt.get("id")

            if new_expr in old_expr:
                msg = f"IP {ip} ƒë√£ t·ªìn t·∫°i trong rule AutoBlock CustomRule tr√™n {domain}"
                send_telegram_message(bot_token, chat_id, msg)
                print(msg)
                return True

            # üîÅ G·ªôp th√™m IP v√†o c√πng bi·ªÉu th·ª©c c≈©
            updated_expr = f"{old_expr} or {new_expr}" if old_expr else new_expr

            # ‚öôÔ∏è C·∫≠p nh·∫≠t l·∫°i filter c≈© thay v√¨ t·∫°o filter m·ªõi ‚Üí tr√°nh unused
            update_filter_payload = {
                "id": old_filter_id,
                "expression": updated_expr,
                "paused": False,
                "description": "AutoBlock-CustomRule"
            }

            upd_filter = requests.put(
                f"{api_filters}/{old_filter_id}", headers=headers, json=update_filter_payload, timeout=15
            ).json()

            if upd_filter.get("success"):
                msg = f"ƒê√£ th√™m IP {ip} v√†o filter {old_filter_id} c·ªßa rule AutoBlock-CustomRule"
                send_telegram_message(bot_token, chat_id, msg)
                print(msg)
                return True
            else:
                msg = f"L·ªói c·∫≠p nh·∫≠t filter: {upd_filter}"
                send_telegram_message(bot_token, chat_id, msg)
                print(msg)
                return False

        else:
            # üöÄ Ch∆∞a c√≥ rule AutoBlock-CustomRule ‚Üí t·∫°o m·ªõi
            filter_payload = [{
                "expression": new_expr,
                "paused": False,
                "description": "AutoBlock-CustomRule"
            }]
            new_filter = requests.post(api_filters, headers=headers, json=filter_payload, timeout=15).json()

            if not new_filter.get("success"):
                msg = f"‚ùå L·ªói t·∫°o filter: {new_filter}"
                send_telegram_message(bot_token, chat_id, msg)
                print(msg)
                return False

            new_filter_id = new_filter["result"][0]["id"]

            rule_payload = [{
                "action": "block",
                "description": "AutoBlock-CustomRule",
                "filter": {"id": new_filter_id}
            }]
            r = requests.post(api_rules, headers=headers, json=rule_payload, timeout=15).json()

            if r.get("success"):
                msg = f"‚úÖ ƒê√£ t·∫°o rule AutoBlock-CustomRule v√† ch·∫∑n IP {ip} tr√™n {domain}"
                send_telegram_message(bot_token, chat_id, msg)
                print(msg)
                return True
            else:
                msg = f"‚ùå L·ªói t·∫°o rule m·ªõi: {r}"
                send_telegram_message(bot_token, chat_id, msg)
                print(msg)
                return False

    except Exception as e:
        msg = f"‚ö†Ô∏è Exception khi x·ª≠ l√Ω Cloudflare: {e}"
        send_telegram_message(bot_token, chat_id, msg)
        print(msg)
        return False
